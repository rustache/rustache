use std::path::Path;
use std::fmt;
use std::io::fs::PathExtensions;
use std::io::File;
use compiler;
use parser;
use parser::{Node, Value, Static, Unescaped, Section, Part};
use super::{Data, Strng, Bool, Integer, Float, Vector, Hash, Lambda};
use build::HashBuilder;
use std::collections::HashMap;

pub struct Template<'a> {
   partials_path: String
}

impl<'a> Template<'a> {
    pub fn new() -> Template<'a> {
        let tmpl = Template {
            partials_path: String::new()
        };
        tmpl
    }  

    fn write_to_stream<'a, W: Writer>(&self, writer: &mut W, data: &str, errstr: &str) {

        let rv = writer.write_str(data);
        match rv {
            Err(err) => {
                let msg = format!("{}: {}", err, errstr);
                fail!(msg);
            }
            Ok(_) => {}
        }
    }

    fn escape_html(&self, input: &str) -> Box<String> {
        let mut rv = box String::new();
        for c in input.chars() {
            match c {
                '<'  => { rv.push_str("&lt;"); }
                '>'  => { rv.push_str("&gt;"); }
                '&'  => { rv.push_str("&amp;"); }
                '"'  => { rv.push_str("&quot;"); }
                _    => { rv.push(c); }
            }
        }
        rv
    }

    // any kind of tag may be in a nested section, in which case it's data
    // may be in a context further up, so we have to have a way to search
    // up those contexts for a value for some key.
    //
    // the sections parameter is a vector that contains the list of nested
    // sections we're in when the method is called
    fn look_up_data<'a>(&self, 
                        key: &String,
                   sections: &Vec<String>, 
                  datastore: &'a HashMap<String, Data<'a>>) -> Option<&'a Data<'a>> {
        let mut rv: Option<&Data<'a>> = None;

        // we're only in the current context
        if sections.len() == 0 {

            rv = datastore.find(key);

        } else {

            // iterate through vector looking for data
            for section in sections.iter() {

                match datastore.find(section) {
                    None => { },
                    Some(data) => {
                        match *data {
                            Hash(ref h) => {
                                rv = h.find(key);
                                if rv.is_some() {
                                    break;
                                }
                            }, 
                            _ => { }
                        }
                    }
                }
            }

            if rv.is_none() {
                rv = datastore.find(key);
            }
        }

        if rv.is_some() {
            println!("in look_up_data: key: {}, sections: {}, data: {}", key, sections, rv.unwrap());
        } else {
            println!("in look_up_data: key: {}, sections: {}, data: None", key, sections);
        }
        return rv;
    }


    fn handle_unescaped_lambda_interpolation<'b, W: Writer>(&mut self, 
                                                        f: &mut |String|: 'a -> String, 
                                                        data: &'b HashMap<String, Data<'b>>, 
                                                        raw: String, 
                                                        writer: &mut W) {
        let val = (*f)(raw);
        let tokens = compiler::create_tokens(val.as_slice());
        let nodes = parser::parse_nodes(&tokens);

        self.render(writer, data, &nodes);
    }

    fn handle_escaped_lambda_interpolation<'b, W: Writer>(&mut self, 
                                                      f: &mut |String|: 'a -> String, 
                                                      data: &'b HashMap<String, Data<'b>>, 
                                                      raw: String, 
                                                      writer: &mut W) {
        let val = (*f)(raw);
        let value = self.escape_html(val.as_slice());
        let tokens = compiler::create_tokens(value.as_slice());
        let nodes = parser::parse_nodes(&tokens);

        self.render(writer, data, &nodes);
    }

    fn handle_unescaped_node<'a, W: Writer>(&mut self, 
                                            key: &String, 
                                            sections: &Vec<String>,
                                            datastore: &'a HashMap<String, Data<'a>>, 
                                            writer: &mut W) {
        let data = self.look_up_data(key, sections, datastore);
        if data.is_some() {
            let mut tmp: String = String::new();
            match *data.unwrap() {
                Strng(ref val) => {
                    tmp = tmp + *val;
                    self.write_to_stream(writer, tmp.as_slice(), "render: unescaped node string fail");
                },
                Bool(ref val) => {
                    match val {
                        &true  => tmp.push_str("true"),
                        &false => tmp.push_str("false")
                    }
                    self.write_to_stream(writer, tmp.as_slice(), "render: unescaped node bool");
                },
                Integer(ref val) => {
                    tmp = tmp + val.to_string();
                    self.write_to_stream(writer, tmp.as_slice(), "render: unescaped node int");
                },
                Float(ref val) => {
                    tmp = tmp + val.to_string();
                    self.write_to_stream(writer, tmp.as_slice(), "render: unescaped node float");
                },
                Vector(ref list) => {
                    for item in list.iter() {
                        self.handle_unescaped_node(item, key.to_string(), datastore, writer);
                    }
                },
                Hash(ref hash) => {
                    let s = format_args!(fmt::format, "{}", hash);
                    self.write_to_stream(writer, s.as_slice(), "render: unescaped node hash");
                },
                Lambda(ref f) => {
                    let raw = "".to_string();
                    self.handle_unescaped_lambda_interpolation(&mut *f.borrow_mut(), datastore, raw, writer);
                }

            }
        }
    }

    fn handle_value_node<'a, W: Writer>(&mut self, 
                                        key: &String, 
                                        sections: &Vec<String>,
                                        datastore: &'a HashMap<String, Data<'a>>, 
                                        writer: &mut W) {
        let data = self.look_up_data(key, sections, datastore);
        if data.is_some() {
            let mut tmp: String = String::new();
            match *data.unwrap() {
                Strng(ref val) => {
                    tmp = *self.escape_html(&(*val.as_slice()));
                    self.write_to_stream(writer, tmp.as_slice(), "render: value node string");
                },
                Bool(ref val) => {
                    match val {
                        &true  => tmp.push_str("true"),
                        &false => tmp.push_str("false")
                    }
                    self.write_to_stream(writer, tmp.as_slice(), "render: value node bool");
                },
                Integer(ref val) => {
                    let val = val.to_string();
                    tmp = *self.escape_html(&(*val.as_slice()));
                    self.write_to_stream(writer, tmp.as_slice(), "render: value node int");
                },
                Float(ref val) => {
                    let val = val.to_string();
                    tmp = *self.escape_html(&(*val.as_slice()));
                    self.write_to_stream(writer, tmp.as_slice(), "render: value node float");
                },
                Vector(ref list) => {
                    for item in list.iter() {
                        self.write_to_stream(writer, s.as_slice(), "render: value node vector");
                    }
                },
                Hash(ref hash) => {
                    let s = format_args!(fmt::format, "{}", hash);
                    self.write_to_stream(writer, s.as_slice(), "render: value node hash");
                },
                Lambda(ref f) => {
                    let raw = "".to_string();
                    self.handle_escaped_lambda_interpolation(&mut *f.borrow_mut(), datastore, raw, writer);
                }
            }
        }       
    }

    fn handle_inverted_node<'a, W:Writer>(&mut self, 
                                          nodes: &Vec<Node>, 
                                          data: &'a HashMap<String, Data<'a>>, 
                                          writer: &mut W) {
        for node in nodes.iter() {
            match *node {
                Static(key) => {
                    self.write_to_stream(writer, key.as_slice(), "render: inverted node static");
                },
                Part(filename, _) => {
                    self.handle_partial_file_node(filename, data, writer);
                },
                _ => {}
            }
        }
    }

    // nodes: the section's children
    // data: data from section key from HashBuilder store
    // datastore: HashBuilder data
    // writer: io stream
    fn handle_section_node<'a, W: Writer>(&mut self, 
                                              nodes: &Vec<Node>, 
                                                key: &String, 
                                          datastore: &'a HashMap<String,Data<'a>>, 
                                           sections: &mut Vec<String>,
                                             writer: &mut W) {
        println!("in handle_section_node: key: {}", key);
        println!("in handle_section_node: sections: {}", sections);
        println!("in handle_section_node: nodes: {}", nodes);
        println!("in handle_section_node: datastore: {}", datastore);
        let data = self.look_up_data(key, sections, datastore);
        if data.is_some() {
            match *data.unwrap() {
                Lambda(ref f) => {
                    let raw = self.get_section_text(nodes);
                    self.handle_unescaped_lambda_interpolation(&mut *f.borrow_mut(), datastore, *raw, writer);
                    return;
                },
                _ => {}
            }
        }
        sections.insert(0, key.clone());
        for node in nodes.iter() {
            match *node {
                Unescaped(key, _)  => {
                    let tmp = key.to_string();
                    self.handle_unescaped_node(&tmp, sections, datastore, writer);
                }
                Value(key, _) => {
                    let tmp = key.to_string();
                    self.handle_value_node(&tmp, sections, datastore, writer);
                }
                Static(key) => {
                    self.write_to_stream(writer, key.as_slice(), "render: section node static");
                }
                Section(ref nextkey, ref children, ref inverted, ref open, ref close) => {
                    match inverted {
                        &false => {

                            let keystr = nextkey.to_string();
                            sections.insert(0, nextkey.to_string());
                            self.handle_section_node(children, &keystr, datastore, sections, writer);  

                        },
                        &true => {
                            self.handle_inverted_node(children, datastore, writer);
                        }
                    }
                },
                Part(path, _) => {
                    self.handle_partial_file_node(path, datastore, writer);
                }
            }
        }
    }

    // section data is considered false in a few cases:
    // there is no data for the key in the data hashmap
    // the data is a bool with a value of false
    // the data is an empty vector
    fn is_section_data_true(&self, data: &Data) -> bool {
        let mut rv = true;

        match data {
            // if the data is a bool, rv is just the bool value
            &Bool(value) => { rv = value; },
            &Vector(ref vec) => {
                if vec.len() == 0 {
                    rv = false;
                }
            },
            _ => { }
        }

        return rv;
    }

    fn get_section_text(&self, children: &Vec<Node>) -> Box<String> {
        let mut temp = box String::new();
        for child in children.iter() {
            match child {
                &Static(text) => temp.push_str(text),
                &Value(_, ref text) => temp.push_str(text.as_slice()),
                &Section(_, ref children, _, ref open, ref close) => {
                    let rv = self.get_section_text(children);
                    temp.push_str(open.as_slice());
                    temp.push_str(rv.as_slice());
                    temp.push_str(close.as_slice());
                },
                &Unescaped(_, ref text) => temp.push_str(text.as_slice()),
                &Part(_, text) => temp.push_str(text)
            }
        }
        temp
    }

    fn handle_partial_file_node<'a, W: Writer>(&mut self,
                                              filename: &str, 
                                                  data: &'a HashMap<String, Data<'a>>, 
                                                writer: &mut W) {
        let path = Path::new(self.partials_path.clone()).join(filename);
        if path.exists() {

            let file = File::open(&path).read_to_string();
            match file {
                Ok(contents) => {
                    let tokens = compiler::create_tokens(contents.as_slice());
                    let nodes = parser::parse_nodes(&tokens);

                    self.render(writer, data, &nodes);    
                },
                Err(_) => { }
            }
        }
    }

    // writer: an io::stream to write the rendered template out to
    // data:   the internal HashBuilder data store
    // parser: the parser object that has the parsed nodes, see src/parse.js
    pub fn render<'a, W: Writer>(&mut self, writer: &mut W, data: &'a HashMap<String, Data<'a>>, nodes: &Vec<Node>) {
        let mut tmp: String = String::new();

        // nodes are what the template file is parsed into
        // we have to iterate through each one and handle it as
        // the kind of node it is
        for node in nodes.iter() {
            tmp.truncate(0);
            match *node {
                // unescaped nodes contain tags who's data gets written
                // out exactly as provided, no HTML escaping
                Unescaped(key, _)  => {
                    let tmp = key.to_string();
                    let sections = vec![];
                    self.handle_unescaped_node(&tmp, &sections, data, writer);
                }
                // value nodes contain tags who's data gets HTML escaped
                // when it gets written out
                Value(key, _) => {
                    let tmp = key.to_string();
                    let sections = vec![];
                    self.handle_value_node(&tmp, &sections, data, writer);
                }
                // static nodes are the test in the template that doesn't get modified, 
                // just gets written out character for character
                Static(key) => {
                    self.write_to_stream(writer, key, "render: static");
                }
                // sections come in two kinds, normal and inverted
                //
                // inverted are if the tag data is not there, the Static between it 
                // and it's closing tag gets written out, otherwise the text is thrown out
                //
                // normal section tags enclose a bit of html that will get repeated
                // for each element found in it's data
                Section(ref key, ref children, ref inverted, _, _) => {
                    let tmp = key.to_string();
                    let truthy = if data.contains_key(&tmp) {
                        self.is_section_data_true(&data[tmp])
                    } else {
                        false
                    };
                    match (truthy, *inverted) {
                        (true, true) => {},
                        (false, false) => {},
                        (true, false) => {
                            let mut sections = vec![tmp.clone()];
                            self.handle_section_node(children, &tmp, data, &mut sections, writer);
                        },
                        (false, true) => {
                            self.handle_inverted_node(children, data, writer);
                        }
                    }
                }
                // partials include external template files and compile and process them
                // at runtime, inserting them into the document at the point the tag is found
                Part(name, _) => {
                    self.handle_partial_file_node(name, data, writer);
                }
            }
        }
    }

    // main entry point to Template
    pub fn render_data<'a, W: Writer>(&mut self, 
                                      writer: &mut W, 
                                      datastore: &'a HashBuilder<'a>, 
                                      nodes: &Vec<Node>) {
        // we need to hang on to the partials path internally,
        // if there is one, for class methods to use.
        self.partials_path.truncate(0);
        self.partials_path.push_str(datastore.partials_path);

        self.render(writer, &datastore.data, nodes);
    }

}
//} // end mod template


#[cfg(test)]
mod template_tests {
    use std::io::File;
    use std::io::MemWriter;
    use std::str;

    use parser;
    use parser::{Node, Static, Value, Section, Unescaped, Part};
    use rustache;
    use compiler;
    use template::Template;
    use build::HashBuilder;


    #[test]
    fn test_escape_html() {
        let s1 = "a < b > c & d \"spam\"\'";
        let a1 = "a &lt; b &gt; c &amp; d &quot;spam&quot;'";
        let s2 = "1<2 <b>hello</b>";
        let a2 = "1&lt;2 &lt;b&gt;hello&lt;/b&gt;";

        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Value("value", "{{ value }}".to_string())];
        let data = HashBuilder::new().insert_string("value", s1);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!(a1, str::from_utf8(w.get_ref()).unwrap());

        w = MemWriter::new();
        let newdata = HashBuilder::new().insert_string("value", s2);
        Template::new().render_data(&mut w, &newdata, &nodes);
        assert_eq!(a2, str::from_utf8(w.get_ref()).unwrap());
    }

    #[test]
    fn test_not_escape_html() {
        let s = "1<2 <b>hello</b>";
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Unescaped("value", "{{ value }}".to_string())];
        let data = HashBuilder::new().insert_string("value", s);

        Template::new().render_data(&mut w, &data, &nodes);
        assert_eq!(s, str::from_utf8(w.get_ref()).unwrap());        
    }

    #[test]
    fn test_render_to_io_stream() {
        let mut w = MemWriter::new();
        let data = HashBuilder::new().insert_string("value1", "The heading");
        let nodes: Vec<Node> = vec![Static("<h1>"), Value("value1", "{{ value1 }}".to_string()), Static("</h1>")];

        Template::new().render_data(&mut w, &data, &nodes);
        assert_eq!("<h1>The heading</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_unescaped_node_correct_string_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Value("value1", "{{ value1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_string("value1", "heading");

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<h1>heading</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_unescaped_node_correct_html_string_data() {
        let s1 = "a < b > c & d \"spam\"\'";
        let a1 = "<h1>a < b > c & d \"spam\"\'</h1>";
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Unescaped("value1", "{{& value1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_string("value1", s1);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!(a1.to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_unescaped_node_correct_bool_false_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Unescaped("value1", "{{& value1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_bool("value1", false);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<h1>false</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_unescaped_node_correct_bool_true_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Unescaped("value1", "{{& value1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_bool("value1", true);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<h1>true</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }


    #[test]
    fn test_section_unescaped_string_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Section("value1", vec![Unescaped("value", "{{& value }}".to_string())], false, "{{# value1 }}".to_string(), "{{/ value1 }}".to_string())];
        let data = HashBuilder::new()
            .insert_hash("value1", |builder| {
                builder.insert_string("value", "<Section Value>")
            });

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<Section Value>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_section_value_string_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Section("value1", vec![Value("value", "{{ value }}".to_string())], false, "{{# value1 }}".to_string(), "{{/ value1 }}".to_string())];
        let data = HashBuilder::new()
            .insert_hash("value1", |builder| {
                builder.insert_string("value", "<Section Value>")
            });

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("&lt;Section Value&gt;".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    // #[test]
    // fn test_section_multiple_value_string_data() {
    //     let mut w = MemWriter::new();
    //     let nodes: Vec<Node> = vec![Section("names", vec![Value("name", "{{ name }}".to_string())], false, "{{# names }}".to_string(), "{{/ names }}".to_string())];
    //     let data = HashBuilder::new()
    //         .insert_hash("names", |builder| {
    //             builder.insert_vector("name", |builder| {
    //                 builder
    //                     .push_string("tom")
    //                     .push_string("robert")
    //                     .push_string("joe")
    //             })
    //         });

    //     Template::new().render_data(&mut w, &data, &nodes);

    //     assert_eq!("tomrobertjoe".to_string(), String::from_utf8(w.unwrap()).unwrap());
    // }

    // #[test]
    // fn test_excessively_nested_data() {
    //     let mut w = MemWriter::new();
    //     let nodes: Vec<Node> = vec![Section("hr", vec![Section("people", vec![Value("name", "{{ name }}".to_string())], false, "{{# people }}".to_string(), "{{/ people }}".to_string())], false, "{{# hr }}".to_string(), "{{/ hr }}".to_string())];
    //     let data = HashBuilder::new()
    //         .insert_hash("hr", |builder| {
    //             builder.insert_hash("people", |builder| {
    //                 builder
    //                     .insert_vector("name", |builder| {
    //                         builder
    //                             .push_string("tom")
    //                             .push_string("robert")
    //                             .push_string("joe")
    //                 })
    //             })
    //         });

    //     Template::new().render_data(&mut w, &data, &nodes);
    //     assert_eq!("tomrobertjoe".to_string(), String::from_utf8(w.unwrap()).unwrap());
    // }    

    #[test]
    fn test_value_node_correct_html_string_data() {
        let s1 = "a < b > c & d \"spam\"\'";
        let a1 = "a &lt; b &gt; c &amp; d &quot;spam&quot;'";
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Value("value1", "{{ value1 }}".to_string())];
        let data = HashBuilder::new().insert_string("value1", s1);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!(a1.to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_value_node_correct_string_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Value("value1", "{{ value1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_string("value1", "heading");

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<h1>heading</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_unescaped_node_lambda_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Unescaped("func1", "{{& func1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_lambda("func1", |_| {
            "heading".to_string()
        });

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<h1>heading</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_value_node_lambda_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("<h1>"), Value("func1", "{{ func1 }}".to_string()), Static("</h1>")];
        let data = HashBuilder::new().insert_lambda("func1", |_| {
            "heading".to_string()
        });

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("<h1>heading</h1>".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_value_node_correct_html_string_lambda_data() {
        let s1 = "a < b > c & d \"spam\"\'";
        let a1 = "a &lt; b &gt; c &amp; d &quot;spam&quot;'";
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Value("func1", "{{ func1 }}".to_string())];
        let data = HashBuilder::new().insert_lambda("func1", |_| {
            s1.to_string()
        });

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!(a1.to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_value_node_correct_false_bool_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Value("value1", "{{ value1 }}".to_string())];
        let data = HashBuilder::new().insert_bool("value1", false);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("false".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_value_node_correct_true_bool_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Value("value1", "{{ value1 }}".to_string())];
        let data = HashBuilder::new().insert_bool("value1", true);

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("true".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_partial_node_correct_data() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("A wise woman once said: "), Part("hopper_quote.partial", "{{> hopper_quote.partial }}")];
        let data = HashBuilder::new().insert_string("author", "Grace Hopper")
                                     .set_partials_path("test_data");

        let mut s: String = String::new();
        s.push_str("A wise woman once said: It's easier to get forgiveness than permission.-Grace Hopper");

        Template::new().render_data(&mut w, &data, &nodes);
        assert_eq!(s, String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_partial_node_correct_data_with_extra() {
        let mut w = MemWriter::new();
        let nodes: Vec<Node> = vec![Static("A wise woman once said: "), Part("hopper_quote.partial", "{{> hopper_quote.partial }}"), Static(" something else "), Value("extra", "{{ extra }}".to_string())];
        let data = HashBuilder::new().insert_string("author", "Grace Hopper")
                                     .insert_string("extra", "extra data")
                                     .set_partials_path("test_data");

        let mut s: String = String::new();
        s.push_str("A wise woman once said: It's easier to get forgiveness than permission.-Grace Hopper something else extra data");

        Template::new().render_data(&mut w, &data, &nodes);
        assert_eq!(s, String::from_utf8(w.unwrap()).unwrap());
    }

    #[test]
    fn test_section_node_partial_node_correct_data() {
        let mut w = MemWriter::new();
        let data = HashBuilder::new()
            .set_partials_path("test_data")
            .insert_hash("people", |builder| {
                builder.insert_vector("information", |builder| {
                    builder
                        .push_string("<tr><td>Jarrod</td><td>Ruhland</td></tr>")
                        .push_string("<tr><td>Sean</td><td>Chen</td></tr>")
                        .push_string("<tr><td>Fleur</td><td>Dragan</td></tr>")
                        .push_string("<tr><td>Jim</td><td>O'Brien</td></tr>")
                    }
                )}
            );

        let file = rustache::read_file(Path::new("test_data/section_with_partial_template.html"));
        let tokens = compiler::create_tokens(file.as_slice());
        let nodes = parser::parse_nodes(&tokens);

        Template::new().render_data(&mut w, &data, &nodes);

        let mut f = File::create(&Path::new("test_data/section_with_partial.html"));
        let completed = f.write(w.unwrap().as_slice());
        assert_eq!(completed, Ok(()));
    }

  // - name: Interpolation - Multiple Calls
  //   desc: Interpolated lambdas should not be cached.
  //   data:
  //     lambda: !code
  //       ruby:    'proc { $calls ||= 0; $calls += 1 }'
  //       perl:    'sub { no strict; $calls += 1 }'
  //       js:      'function() {return (g=(function(){return this})()).calls=(g.calls||0)+1 }'
  //       php:     'global $calls; return ++$calls;'
  //       python:  'lambda: globals().update(calls=globals().get("calls",0)+1) or calls'
  //       clojure: '(def g (atom 0)) (fn [] (swap! g inc))'
  //   template: '{{lambda}} == {{{lambda}}} == {{lambda}}'
  //   expected: '1 == 2 == 3'
    #[test]
    fn test_spec_lambda_not_cached_on_interpolation() {
        let mut planets = vec!["Jupiter", "Earth", "Saturn"];
        let mut w = MemWriter::new();
        let tokens = compiler::create_tokens("{{lambda}} == {{&lambda}} == {{lambda}}");
        let nodes = parser::parse_nodes(&tokens);
        let data = HashBuilder::new().insert_lambda("lambda", |_| { planets.pop().unwrap().to_string() } )
                                     .insert_string("planet", "world");

        Template::new().render_data(&mut w, &data, &nodes);

        assert_eq!("Saturn == Earth == Jupiter".to_string(), String::from_utf8(w.unwrap()).unwrap());
    }


}
